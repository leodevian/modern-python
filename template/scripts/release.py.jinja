# /// script
# requires-python = "{% if dynamic_version %}>=3.10{% else %}>=3.11{% endif %}"
# dependencies = [
{%- if dynamic_version %}
#   "packaging>=24.2",
{%- endif %}
#   "towncrier>=24.8",
{%- if not dynamic_version %}
#   "uv>=0.8.6",
{%- endif %}
# ]
# ///
"""Make a release."""

# ruff: noqa: S603, T201

from __future__ import annotations

import argparse
{%- if not dynamic_version %}
import enum
{%- endif %}
import json
import subprocess
import sys
from contextlib import contextmanager
from functools import partial
from typing import TYPE_CHECKING
{% if dynamic_version %}
from packaging.version import Version
{% endif %}
if TYPE_CHECKING:
    from collections.abc import Generator, Sequence

print_error = partial(print, file=sys.stderr)

run = partial(
    subprocess.check_call,
    stdout=subprocess.DEVNULL,
    stderr=subprocess.DEVNULL,
)

{% if not dynamic_version %}
class Bump(enum.StrEnum):
    """The enumeration of supported version bump semantics."""

    MAJOR = enum.auto()
    MINOR = enum.auto()
    PATCH = enum.auto()
    STABLE = enum.auto()
    ALPHA = enum.auto()
    BETA = enum.auto()
    RC = enum.auto()
    POST = enum.auto()
    DEV = enum.auto()

{% endif %}
def create_parser() -> argparse.ArgumentParser:
    """Create the argument parser."""
    parser = argparse.ArgumentParser(description="make a release")
{%- if dynamic_version %}
    parser.add_argument(
        "--version",
        type=Version,
        help="provide the version",
    )
{%- else %}
    mutex = parser.add_mutually_exclusive_group(required=True)
    mutex.add_argument(
        "--version",
        help="provide the version",
    )
    mutex.add_argument(
        "--bump",
        type=Bump,
        choices=Bump,
        help="update the version using the given semantics",
    )
{%- endif %}
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="do not push changes and reset the repository",
    )
    return parser


def check_repository() -> None:
    """Check whether the repository is dirty."""
    try:
        run(("git", "diff", "--quiet"))

    except subprocess.CalledProcessError:
        print_error("The Git repository is dirty.")
        raise SystemExit(1) from None

{% if not dynamic_version %}
def update_version(version: str | None = None, bump: str | None = None) -> str:
    """Update the version and return the new version."""
    cmd = ["uv", "version", "--no-sync", "--output-format", "json"]

    if version:
        cmd.append(version)

    if bump:
        cmd.extend(("--bump", bump))

    try:
        version_json = subprocess.check_output(cmd)

    except subprocess.CalledProcessError:
        print_error("An error occurred while bumping the version.")
        raise SystemExit(1) from None

    version = json.loads(version_json)
    return version["version"]

{% endif %}
def get_branch() -> str:
    """Get the current branch."""
    return subprocess.check_output(
        ("git", "rev-parse", "--abbrev-ref", "HEAD"),
        text=True,
    ).rstrip()


def create_branch(branch: str) -> None:
    """Create a new branch."""
    try:
        run(("git", "branch", branch))

    except subprocess.CalledProcessError:
        print_error(f"The branch already exists: {branch!r}.")
        raise SystemExit(1) from None

    print(f"Created new branch {branch!r}.")


@contextmanager
def switch_to_branch(branch: str) -> Generator[None]:
    """Create a new branch and switch to it.

    It is removed on exit.
    """
    base_branch = get_branch()
    create_branch(branch)

    try:
        run(("git", "checkout", branch))
        print(f"Switched from branch {base_branch!r} to branch {branch!r}.")
        yield

    finally:
        run(("git", "checkout", base_branch))
        run(("git", "branch", "-D", branch))
        print(f"Removed branch {branch!r} and switched back to {base_branch!r}.")


def build_changelog(version: str) -> None:
    """Build the changelog."""
    try:
        run(("towncrier", "build", "--yes", "--version", version))

    except subprocess.CalledProcessError:
        print_error("An error occurred while building the changelog.")
        raise SystemExit(1) from None


def create_release_tag(version: str) -> str:
    """Create the release tag."""
    release_tag = f"v{version}"
    message = f"bump version to {version}"

    try:
        run(("git", "tag", "-a", release_tag, "-m", message))

    except subprocess.CalledProcessError:
        print_error(f"The release tag already exists: {release_tag!r}.")
        raise SystemExit(1) from None

    print(f"Created release tag {release_tag!r}.")
    return release_tag


def push_changes(branch: str, remote_branch: str = "main") -> None:
    """Push the changes to the target branch."""
    run(("git", "push", "origin", f"{branch}:{remote_branch}", "--follow-tags"))
    print(f"Pushed changes from {branch!r} to 'origin/{remote_branch}'.")


def main(argv: Sequence[str] | None = None) -> int:
    """Prepare a new release."""
    parser = create_parser()
    args = parser.parse_args(argv)

    check_repository()
{% if dynamic_version %}
    version = args.version.public
{% else %}
    version = update_version(args.version, args.bump)
{% endif %}
    release_branch = f"release/{version}"

    with switch_to_branch(release_branch):
        build_changelog(version)

        # Commit changes.
{%- if not dynamic_version %}
        run(("git", "add", ":/pyproject.toml", ":/uv.lock"))
{%- endif %}
        run(("git", "add", "-A", ":/changelog.d/*", ":/CHANGELOG.md"))
        message = f"chore: prepare release {version}"
        run(("git", "commit", "--no-verify", "-m", message))
        print(f"Committed changes on branch {release_branch!r}.")

        release_tag = create_release_tag(version)

        # Exit on dry run.
        if args.dry_run:
            print("Dry run success!")
            run(("git", "tag", "-d", release_tag))
            print(f"Removed release tag {release_tag!r}.")
            return 0

        push_changes(release_branch, "main")

    # Switch to the main branch.
    run(("git", "checkout", "main"))
    run(("git", "fetch"))
    run(("git", "reset", "--hard", "origin/main"))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
